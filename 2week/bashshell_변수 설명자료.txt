1. 쉘 작성 첫번째 행 - Shebang
-------------------------------------------
#!/usr/bin/bash
echo $(which bash) # 디렉토리 위치 출력
-----------------------------------
- 실행권한(x)를 주고 쉘을 실행

2. 쉘 변수 선언
 - 변수의 타입에는 로컬변수와 전역변수, 환경변수, 예약변수, 매개변수 등 다양
 - 변수는 대, 소문자를 구별
 - 변수의 이름은 숫자를 포함할 수 있지만, 숫자로 시작할 수 없음.
- 변수에는 모든 값을 문자열로 저장.
 - 변수에는 자료형을 기입하지 않음. (int number, char names[10]), 즉 아무런 값을 다 넣을 수 있음.
- 값을 사용할 때는 변수명 앞에 특수문자 "$"를 사용한다. (Ex. echo ${data})
- 값을 대입(삽입)할 때는 특수문자 "$"를 사용하지 않음. (Ex. data=mac)
- 변수를 생성할 때는 "=" 대입문자 앞뒤로 공백이 없어야 함 (Ex. data="abcd")

----------------------------bashshel_variable_sample_1.sh-----------------
#!/usr/bin/bash

name="bluewind" # 변수 선언 및 대입
pass=123123 # 따옴표로 감싸든 말든 문자열로 저장됨

echo $name # {}가 있으나 없으나 $만으로 변수의 값을 넣어줄 수 있으나, 문자열을 붙여서 쓸려면 ${} 를 사용해야 함.
echo "my name is mr.${name}"
printf "%s" $pass
-----------------------------------------------------------

2-1) 전역 변수 & 지역 변수
- 쉘에서 선언된 변수는 기본적으로 전역 변수(global variable)
단, 함수 안에서만 지역 변수(local variable)를 사용할 수 있는데 사용할려면 변수 명 앞에 local을 붙여주면 됨.

------------------------bashshel_variable_sample_2.sh------------------------------------
#!/usr/bin/bash

# 기본적으로 전역 변수로 지정
string="hello world"

function string_test() {
    # local을 붙여야 지역변수로 인식. 만일 local을 빼면 전역변수 덮어쓰기가 되버림
    local string="hello local @@"
    echo ${string}
}

# 함수 호출
string_test # > hello local @@
echo ${string} # > hello world

# 변수 초기화
unset string
----------------------------------------------------

2-2) 변수 타입 지정
- 기본적으로 Bash 변수는 문자열만 저장.
  다른 프로그래밍 언어같이 변수 자료형 타입을 미리 지정해주는 문법도 존재

---------------------------------------------------------------------.
  declare 옵션 (-[옵션])
-i (Integer): 변수를 정수형으로 선언. 산술 연산이 자동으로 처리
예: declare -i num=10

-a (Array): 변수를 인덱스 배열(Array)로 선언
예: declare -a fruits=("apple" "banana")

-A (Associative Array): 변수를 연관 배열(Key-Value Map)로 선언 (Bash 4.0 이상).
예: declare -A user=(["name"]="kim" ["age"]="20")

-r (Read-only): 변수를 읽기 전용으로 설정. 이후 값을 변경하거나 unset할 수 없음.
예: declare -r PI=3.14

-x (Export): 변수를 환경 변수(Environment Variable)로 내보냄. 자식 쉘(subshell)에서 사용 가능.
예: declare -x VAR="hello"

-l (Lowercase): 변수 값을 모두 소문자로 변환.
-u (Uppercase): 변수 값을 모두 대문자로 변환.
-f (Function): 변수가 아닌 함수 이름을 표시. -f만 사용하면 스크립트에 정의된 모든 함수 내용을 출력.
-F (Function Name): 함수 이름만 표시 (함수 내용은 숨김).
-g (Global): 함수 내부에서 변수를 선언할 때, 지역 변수(local)가 아닌 전역 변수로 선언. 

기타 유용한 명령어
declare -p [변수명]: 특정 변수의 속성과 현재 값을 표시
+ 사용: declare 옵션 앞에 - 대신 +를 붙이면 해당 속성을 해제.

예: declare +i var (var의 정수 속성을 해제) 

---------------------bashshel_variable_sample_3.sh---------------------------------
#!/bin/bash

# 1. 정수 선언
declare -i count=10
count=count+5  # 15
echo $count

# 2. 읽기 전용 선언
declare -r readonly_var="Secret"
# readonly_var="Open" # 에러 발생

# 3. 배열 선언
declare -a my_array=("one" "two" "three")

# 4. 연관 배열 (HashMap) 선언
declare -A map
map["key1"]="value1"
echo ${map["key1"]}

# 5. 환경 변수 선언
declare -x EXPORT_VAR="export_this"
--------------------------------------------------------------------

2-3) 환경 변수
- 쉘 스크립트에서 변수 명 앞에 export을 붙여주면 환경 변수(environment variable)로 설정되어 자식 스크립트에서 사용 가능
- 다만 환경 변수 사용시 시스템에 미리 정의된 예약 변수(reserved variable)와 변수명이 겹치지 않게 주의

------------------------------# /tmp/export_sample.sh-----------

#!/usr/bin/bash

echo ${hello_world}
-------------------------------------------------------------------------------

# 환경 변수 선언
export hello_world="global hello world"

# 자식 스크립트 호출은 스크립트 경로을 쓰면된다.
/tmp/export_sample.sh

# > 자식스크립트의 코드에서 부모스크립트에서 정의한 hello_world변수값이 출력된

2-4) 매개 변수
- 프로그램에서도 실행할때 인자를 주듯 쉘 스크립트도 가능
- 실행한 스크립트 이름은 ${0}, 그 이후는 전달받은 인자 값들(${1}, ${2}, ...)

 ./test a   b    c    d
  $0   $1  $2  $3  $4    $#: 인자 총 개수:4

$0 : 실행된 셸 스크립트명
$1 :스크립트에 넘겨진 첫 번째 아규먼트 
$2 : 스크립트에 넘겨진 두 번째 아규먼트
$3 S4 등등...쭈욱 이후 $숫자 는 그 이후 해당되는 아규먼트 

$# :  아규먼트 개수 
$* :  스크립트에 전달된 인자 전체를 하나의 변수에 저장하면 IFS 변수의 첫 번째 문자로 구분
$@ : $*와 동일한데 다른 점은 IFS 환경 변수를 사용하지 않는다는 점. 
$!  : 실행을 위해 백그라운드로 보내진 마지막 프로그램 프로세스 번호 
$$ : 셸 스크립트의 PID
$? : 실행한 뒤의 반환 값 (백그라운드로 실행된 것 제외)

--------------bashshel_variable_sample_4.sh--------------------------
#!/bin/bash

echo "script name : ${0}"
echo "매개변수 갯수 : ${#}"
echo "전체 매개변수 값 : ${*}"
echo "전체 매개변수 값2 : ${@}"
echo "매개변수 1 : ${1}"
echo "매개변수 2 : ${2}"
----------------------------------------------------------------------------

./bashshel_variable_sample_4.sh 1 2 3 4 5


2-5) 예약 변수
 - 쉘 스크립트에서 사용자가 정해서 만들 수 없는 이미 정의된 변수가 존재

HOME : 사용자 홈 디렉토리
PATH : 실행 파일의 경로
LANG :프로그램 실행 시 지원되는 언어
UID : 사용자의 UID
SHELL : 사용자가 로그인시 실행되는 쉘
USER :사용자의 계정 이름
FUNCNAME :현재 실행되고 있는 함수 이름
TERM :로그인 터미널

set : 셸 변수를 출력하는 명령어
env : 환경 변수를 출력하는 명령어
export : 특정 변수의 범위를 환경 변수의 데이터 공간으로 전송하여 자식 프로세스에서도 특정 변수를 사용 가능하게 하는 전역 변수의 개념
unset : 선언된 변수를 제거


2-6) 쉘 이스케이프 문자
\f : 앞 문자열만큼 열을 밀어서 이동
\n : 새로운 줄로 바꾼다
\r : 앞 문자열의 앞부분부터 뒷문자열 만큼 대체하고 반환한다.
\t : 탭 만큼 띄운다.


3. 쉘 산술 연산
- 쉘 스크립트의 변수 산술연산은 다른 언어의 비해 간단치 않음
 - Bash 변수는 본질적으로 문자열이라 별도의 특수한 문법을 사용해 연산하게 되는데
  그러면 Bash가 알아서 형변환 하여 정수 연산이나 변수를 비교해 줌
 
 - Bash에서는 계산을 처리할 수 있는 다음 3가지 문법을 제공.
  expr : expr (외부 명령어)
  let   : (Built-in 명령어)
  $(( )) : (쌍괄호

expr (외부 명령어)
특징: 전통적인 방식의 외부 명령어로, 계산 결과를 화면에 출력하고 종료 상태를 반환합니다.
문법: 연산자와 피연산자 사이에 반드시 공백이 있어야 합니다. 곱셈(*) 등 특수 문자는 이스케이프(\)가 필요합

let (Built-in 명령어)
특징: Bash 내장(Built-in) 명령어로, 변수에 산술 연산 결과를 직접 할당할 때 편리합니다.
문법: let "변수=식" 형태로 사용하며, 공백이 있어도 되고 없어도 되지만 묶어서 표현하는 것이 안전합니다.

(( )) (Arithmetic Evaluation, 쌍괄호) 
특징: Bash에서 가장 권장되는 현대적인 산술 연산 방식입니다. let과 기능적으로 같으나 더 읽기 쉽습니다.
문법: ((expression)) 형태. 변수 앞에 $를 붙이지 않아도 됩니다 ($((...))는 결과값을 반환).

 3-1) expr 연산자
 - expr는 역따옴표를 반드시 감싸준다. 역따옴표 대신 $(( )) 해줘도 동작은 함
- expr을 사용할 때 피연산자와 연산자 사이에 공백이 필요.
 - 산술 연산할때 우선순위를 지정하기위해 괄호를 사용하려면 \처리를 해줘야 함.
 - 곱셈 문자 *는 \처리를 해주어야 함

----------- bashshell_expr_demo.sh_--------------------------
#!/bin/bash

number1=10
number2=20

plus=`expr $number1 + $number2` 
minus=`expr $number1 - $number2`
mul=`expr $number1 \* $number2` # 곱셈에는 \* 를 이용
div=`expr $number1 / $number2`
rem=`expr $number1 % $number2`

echo "plus:     ${plus}"
echo "minus:    ${minus}"
echo "mul:      ${mul}"
echo "div:      ${div}"
echo "rem:      ${rem}"
--------------------------------------------------------------------------
3-2) let 연산자
-------------------bashshell_let_demo.sh------------------------------
#!/bin/bash
num1=42
num2=9
 
let re=num1+num2 #Add
echo "add:$re"

let re=num1-num2 #Sub
echo "sub:$re"

let re=num1*num2 #Mul
echo "mul:$re"

let re=num1/num2 #Div
echo "div:$re"

let re=num1%num2 #Mod
echo "mod:$re"

--------------------------------------------------------


3-3) $(( )) 연산자
-------------------bashshell__demo.sh------------------------------
#!/bin/bash

num1=42
num2=9
 
echo add:$((num1+num2))
echo sub:$((num1-num2))
echo mul:$((num1*num2))
echo div:$((num1/num2))
echo mod:$((num1%num2))
----------------------------------------------------------

4. 쉘 주석
- 쉘스크립트를 작성할때 한 줄은 쉽게 '#'를 통해 주석이 가능하지만,
 블록을 주석하기 위해서는 완전히 다른 문법을 사용해야 함.
- :<<"END" 이 구간부터 주석이 시작되는 블록이고, END 로 주석이 끝나는 블록을 명시해 주면 됨.

echo "여기는 출력된다." 
#echo " 여기는 주석처리"

-------------------------------------------
: << "END"              #주석 시작
echo "여기서부터 "
echo "test_01"
echo "test_02"
echo "test_03"
echo "test_04"
echo "test_05"
echo "test_06"
echo "test_07"
echo "여기까지 주석처리 됨"
END                    #주석 끝

echo "여기는 주석이 안되어 있어 출력 "


5. 쉘 조건문
 5-1) if 문
 -  if문의 특이한 점은 fi 와 대괄호[ ] 
 - 다른 언어와 달리 중괄호를 안쓰기 떄문에 fi로 if문의 끝을 알려주어야 하며,
  주의해야할 점은 if문 뒤에 나오는 대괄호 [ ] 와 조건식 사이에는 반드시 공백이 존재해야 함
----------------------------
if [ 값1 조건식 값2 ]
then
    수행1
else
    수행2
fi
------------------
# 가독성 좋기 위해 then을 if [] 와 붙여쓰려면 반드시 세미콜론 ; 을 써야한다.
if [ 값1 조건식 값2 ]; then
    수행1
else
    수행2

-------------------------

5-2) 비교 연산
문자1 = 문자2             # 문자1 과 문자2가 일치 (sql같이 = 하나만 써도 일치로 인식)
문자1 == 문자2            # 문자1 과 문자2가 일치
문자1 != 문자2            # 문자1 과 문자2가 일치하지 않음
-z 문자                   # 문자가 null 이면 참
-n 문자                   # 문자가 null 이 아니면 참
문자 == 패턴              # 문자열이 패턴과 일치
문자 != 패턴              # 문자열이 패턴과 일치하지 않음


값1 -eq 값2             # 값이 같음(equal)
값1 -ne 값2             # 값이 같지 않음(not equal)
값1 -lt 값2             # 값1이 값2보다 작음(less than)
값1 -le 값2             # 값1이 값2보다 작거나 같음(less or equal)
값1 -gt 값2             # 값1이 값2보다 큼(greater than)
값1 -ge 값2             # 값1이 값2보다 크거나 같음(greater or equal)

-------------------------------------------
if [ ${a} -eq ${b} ]; then
    echo "a와 b는 같다."
fi

if [ ${a} -ne ${b} ]; then
    echo "a와 b는 같지 않다."
fi

if [ ${a} -gt ${b} ]; then
    echo "a가 b보다 크다."
fi

if [ ${a} -ge ${b} ]; then
    echo "a가 b보다 크거나 같다."
fi

if [ ${a} -lt ${b} ]; then
    echo "a가 b보다 작다."
fi

if [ ${a} -le ${b} ]; then
    echo "a가 b보다 작거나 같다."
fi

# 한줄로 작성
if [ ${num1} -lt ${num2} ]; then echo "yes"; fi
num1=35
num2=48

# 이중 소괄호를 쓰면 조건문을 문자 대신 기호로 표현 가능하다. 단, 소괄호 안에 따옴표 쓰면 안된다.
if (( ${num1} < ${num2} )); then
    echo "yes"
fi

if (( ($num1 * $num2) - $num2 > 200 )); then
	echo ">200"
else
	echo "<200"
fi

5-3) 파일 검사
 [ -b FILE] : FILE이 블록 디바이스이면 참

----------------
if [ -d ${변수} ]; then     # ${변수}의 디렉토리가 존재하면 참
if [ ! -d ${변수} ]; then	  # ${변수}의 디렉토리가 존재하지 않으면 참


if [ -e ${변수} ]; then     # ${변수}라는 파일이 존재하면 참
if [ ! -e ${변수} ]; then   # ${변수}라는 파일이 존재하지 않으면 참


if [ -r ${변수} ]; then     # 파일을 읽을 수 있으면 참
if [ -w ${변수} ]; then     # 파일을 쓸 수 있으면 참
if [ -x ${변수} ]; then     # 파일을 실행할 수 있으면 참


if [ -s ${변수} ]; then     # 파일의 크기가 0보다 크면 참
if [ -L ${변수} ]; then     # 파일이 symbolic link이면 참
if [ -S ${변수} ]; then     # 파일 타입이 소켓이면 참
if [ -f ${변수} ]; then     # 파일이 정규 파일이면 참
if [ -c ${변수} ]; then     # 파일이 문자 장치이면 참


if [ ${변수1} -nt ${변수2}]; then # 변수1의 파일이 변수2의 파일보다 최신 파일이면 참
if [ ${변수1} -ot ${변수2}]; then # 변수1의 파일이 변수2의 파일보다 최신이 아니면 참
if [ ${변수1} -ef ${변수2}]; then # 변수1의 파일과 변수2의 파일이 동일하면 참
--------------------------------------------


5-4) 논리 연산
조건1 -a 조건2         # AND
조건1 -o 조건2         # OR
조건1 && 조건2         # 양쪽 다 성립
조건1 || 조건2         # 한쪽 또는 양쪽다 성립
!조건                  # 조건이 성립하지 않음
true                   # 조건이 언제나 성립
false                  # 조건이 언제나 성립하지 않음

----------------------------------------------------------
if [ -f ${file1} -a -f ${file2} ]; then
    echo 'file1과 file2는 모두 파일입니다.'
else
    echo 'file1과 file2가 모두 파일인 것은 아닙니다.'
fi


if [ -f ${a} -a -d ${b} ]; then
    echo "a는 파일이고 b는 디렉토리"
fi

-------------------------------
VALUE=10

if [ ${VALUE} -gt 5 -a ${VALUE} -lt 15 ] ; then
	echo "VALUE is greater than 5 and less than 15!"
fi

# 둘이 같은 문장이다.
if [ ${VALUE} -gt 5 ] && [ ${VALUE} -lt 15 ] ; then
	echo "VALUE is greater than 5 and less than 15!"
fi

# 대괄호 두개를 써서 표현할 수 도 있다.
if [[ ${VALUE} -gt 5 && ${VALUE} -lt 15 ]] ; then
	echo "VALUE is greater than 5 and less than 15!"
fi
------------------------------------------------------
# AND 
if [ ${string1} == ${string2} ] && [ ${string3} == ${string4} ] ;
then

# OR 
if [ ${string1} == ${string2} ] || [ ${string3} == ${string4} ];
then 

# 다중 조건 
if [[ ${string1} == ${string2} || ${string3} == ${string4} ]] && [ ${string5} == ${string6} ];
then


5-5)if elif else 문
--------------------------------------
if elif else 문
#!/bin/bash

num1="10"
num2="10"

if [ ${num1} -lt ${num2} ]; then # "-lt", A가 B보다 작으면 True
    echo "yes"
elif [ ${num1} -eq ${num2} ]; then # "-eq", A와 B가 서로 같으면 True
    echo "bbb"
else
    echo "no"
fi


# 이중 소괄호를 쓰면 논리연산자 기호 사용 가능
if (( ${num1} < ${num2} )); then
    echo "yes"
elif (( ${num1} == ${num2} )); then
    echo "bbb"
else
    echo "no"
fi


# 한줄 작성
if [ ${num1} -lt ${num2} ]; then echo "yes"; elif [ ${num1} -eq ${num2} ]; then echo "bbb";  else echo 
--------------------------------------------------------------

5-6) case 문
- Bash의 switch문 특징이라면 각 case의 끝을 보면 세미콜론 2개로 종료
-----------------
case 문자열 in
 경우1) 
    명령 명령 명령
    ;;
 경우2)
    명령 명령 명령
    ;;
 * )
    명령 명령 명령
    ;;
esac
-------------------------------------------
case ${var} in
    "linux") echo "리눅스" ;; # 변수var값이 linux라면 실행 
    "unix") echo "유닉스" ;;    
    "windows") echo "윈도우즈" ;;    
    "MacOS") echo "맥OS" ;;    
    *) echo "머야" ;; # default 부분
esac


5-7) for 문
-------------------------------------
#!/bin/bash

# 초기값; 조건값; 증가값을 사용한 정통적인 for문
for ((i=1; i<=4; i++)); do
    echo $i
done



5-8) for in 문
--------------------
#!/bin/bash

# 루프 돌 데이터에 띄어쓰기가 있으면 각각 돌음
for x in 1 2 3 4 5
do
	echo "${x}"
done


# 변수를 사용한 반복문
data="1 2 3 4 5"
for x in $data
do
	echo ${x}
done


# 배열을 사용한 반복문
arr=(1 2 3 4 5)
for i in "${arr[@]}" # arr[@] : 배열 전체 출력
do
	echo "${i}"
done


# sequence를 통한 for문. seq라는 프로세스가 순서대로 숫자를 출력해 주는 역할을 bash에 사용한 것이다.
for num in `seq 1 5`
do
  echo $num
done
-------------------------------------------------------------


5-9) while 문
count=0
while [ ${count} -le 5 ]; 
do
    echo ${count}
    count=$(( ${count}+1 ))
done

--------------

count=0
while (( ${count} <= 5 ));  # 이중괄호 사용하면 논리기호 사용 가능
do
    echo ${count}
    count=$(( ${count}+1 ))
done



5-10) unitil 문
- 수행 조건이 false 일때 실행되는 루프문



6. 쉘 배열문
  6-1) 배열 생성 / 추가
-------------------------------------------
#!/bin/bash

# 배열의 크기 지정없이 배열 변수 선언
# 굳이 'declare -a' 명령으로 선언하지 않아도 바로 배열 변수 사용 가능함
declare -a array

arr=("test1" "test2" "test3") # 배열 선언 및 지정

echo ${arr[0]}  # test1


# 기존 배열에 1개의 배열 값 추가 3가지 방법
arr[3]="test4" 
arr+=("test5")
arr[${#arr[@]}]="test6" # 배열 길이를 인덱스로 사용해 push


echo ${arr[@]}  # arr의 모든 데이터 출력
echo ${arr[*]}  # arr의 모든 데이터 출력
echo ${#arr[@]} # arr 배열 길이 출력

echo ${arr[@]:2:3} # 2부터 3개의 요소
-------------------------------------------------------------

6-2) 배열 원소 삭제
 -  /를 사용해 해당 문자열 부분이 있으면 삭제 가능.
다만 unset을 이용해 삭제를 권고
--------------------------------
arr=(1 2 3)
remove_element=(3)

arr=( "${arr[@]/$remove_element}" ) # 배열 1 2 3 에서 / 3을 없앰

echo ${arr[@]} # > 1 2
----------------------------------------

arr=("abc" "def" "defghi")

unset arr[1] # 배열 특정 인덱스 요소 삭제

echo ${arr[@]} > # abc defghi

unset array # 배열 전체 지우기

-------------------------------------------
6-3)연관배열 (MAP)
- key와 value 타입으로 저장된 배열.
프로그래밍 고급언어에서 자주 등장하는 자료형 타입인데, PHP의 연관배열, 파이썬의 딕셔너리, 자바스크립트의 MAP 자료형 이라고 봐도 됨
--------------------------------
# 연관배열 생성
declare -A map=([hello]='world' [long]='long long long string' [what is it]=123)

declare -p map # 연관배열 정보 출력
# > declare -A map=([long]="long long long string" ["what is it"]="123" [hello]="world" )

echo "map[hello]=${map[hello]}" 
# > map[hello]=world

key=hello # 변수를 인덱스로 넣어줘도 된다. (MAP의 특성)
echo "map[key]=${map[${key}]}" 
# > map[key]=world

----------------

7. 쉘 함수(Function)
 - 다른 프로그래밍 언어와 달리 쉘 스크립트에서는 함수명 앞 function은 써주지 않아도 알아서 인식
   또한, 함수를 호출할때는 괄호를 써주지 않고 호출해야한다는 점이 다르다. 그리고 함수 호출 코드는 함수 코드보다 반드시 뒤에 있어야 된다. 함수 코드 보다 앞에서 호출 시 오류가 발생하기 때문이다.
---------------------------------
#!/bin/bash

func(){
	echo "func()"
}

function string_test() {
    echo "string test"
    echo "인자값: ${@}"
}

#함수 호출
func

# 함수에 인자값 전달하기(공백의로 뛰어서 2개의 인자값을 넘김)
string_test "hello" "world"

--------------------------------------------------------------
함수 아규먼트
- 함수에 인자를 전달하는 방법은 함수를 호출하면서 공백으로 구분하여 이후 인자들을 하나씩 넣어주면 됨
이렇게 넣어준 인자들은 함수 내부에서 다양한 방식으로 사용할 수 있는데,
대표적으로는 $1, $2처럼 인자가 들어온 순서대로 입력을 받아 사용하게 된다.
----------------------------
function test3()
{
    param1=$1
    param2=$2
    echo $param1 # a
    echo $param2 # b
    echo $@ # 파라미터 전체 출력
}

test3 "a" "b"
----------------------
